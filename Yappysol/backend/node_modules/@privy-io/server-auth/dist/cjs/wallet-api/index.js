"use strict";var e=require("../errors.js"),t=require("../paths.js"),a=require("../utils-D9BZ7JAH.js"),i=require("./import.js"),r=require("./mappers.js"),n=require("./rpc/ethereum.js"),o=require("./rpc/solana.js"),s=require("./utils.js"),d=require("./views.js");function c(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}require("node-fetch-native"),require("ts-case-convert"),require("@scure/base"),require("viem"),require("@hpke/chacha20poly1305"),require("@hpke/core"),require("@noble/curves/p256"),require("@noble/hashes/sha256"),require("canonicalize"),require("../constants.js");var p=0,h="__private_"+p+++"__getRequestHeaders";function l({path:e,body:t,idempotencyKey:a,method:i}){let r=s.extractIdempotencyKeyHeader({idempotencyKey:a}),n={...r};if(this.authorizationPrivateKey){let a=s.signAuthorizationSignatureRequest({method:i,url:`${this.api.baseURL}${e}`,body:t,appId:this.appId,idempotencyKeyHeader:r,authorizationPrivateKey:this.authorizationPrivateKey});void 0!==a&&(n["privy-authorization-signature"]=a)}return n}exports.WalletApi=class{async getWallets(e={}){let{cursor:i,limit:r,chainType:n}=e,{data:o}=await this.api.get(t.getWalletApiSearchPath()+a.getQueryParamsString({cursor:i,limit:r,chain_type:n}));return{nextCursor:o.next_cursor??void 0,data:o.data.map((e=>d.WalletView(e)))}}async getWallet({id:e}){let{data:a}=await this.api.get(t.getWalletApiGetPath(e));return d.WalletView(a)}updateAuthorizationKey(e){this.authorizationPrivateKey=s.normalizeP256PrivateKeyToScalar(e),this.ethereum=new n.EthereumRpcApi({appId:this.appId,api:this.api,authorizationPrivateKey:this.authorizationPrivateKey}),this.solana=new o.SolanaRpcApi({appId:this.appId,api:this.api,authorizationPrivateKey:this.authorizationPrivateKey})}async generateUserSigner({userJwt:e}){let{publicKey:t,privateKey:a}=await s.createP256KeyPair(),{data:i}=await this.api.post("/api/v1/user_signers/authenticate",{encryption_type:"HPKE",recipient_public_key:t.toString("base64"),user_jwt:e});return{authorizationKey:await s.decryptHPKEMessage(a.toString("base64"),i.encrypted_authorization_key.encapsulated_key,i.encrypted_authorization_key.ciphertext),expiresAt:new Date(i.expires_at),wallets:i.wallets.map((e=>d.WalletView(e)))}}async getPolicy({id:e}){let{data:a}=await this.api.get(t.getPolicyPath(e));return r.convertPolicyResponseToPolicy(a)}async createPolicy(e){let a=t.createPolicyPath(),i=r.convertPolicyCreateRequestToPolicy(e),{data:n}=await this.api.post(a,i,{headers:c(this,h)[h]({path:a,body:i,method:"POST"})});return r.convertPolicyResponseToPolicy(n)}async updatePolicy(e){let a=t.updatePolicyPath(e.id),i={name:e.name,rules:e.rules?r.convertPolicyCreateRuleToPolicyRule(e.rules):void 0},{data:n}=await this.api.patch(a,i,{headers:c(this,h)[h]({path:a,body:i,method:"PATCH"})});return r.convertPolicyResponseToPolicy(n)}async deletePolicy(e){let a=t.deletePolicyPath(e.id),i={};await this.api.delete(a,i,{headers:c(this,h)[h]({path:a,body:i,method:"DELETE"})})}async addRuleToPolicy(e){let a=t.createPolicyRulePath(e.policyId),i={name:e.name,action:e.action,method:e.method,conditions:e.conditions},{data:r}=await this.api.post(a,i,{headers:c(this,h)[h]({path:a,body:i,method:"POST"})});return r}async updateRuleInPolicy(e){let a=t.updatePolicyRulePath(e.policyId,e.ruleId),i={name:e.name,action:e.action,method:e.method,conditions:e.conditions},{data:r}=await this.api.patch(a,i,{headers:c(this,h)[h]({path:a,body:i,method:"PATCH"})});return r}async deleteRuleFromPolicy(e){let a=t.deletePolicyRulePath(e.policyId,e.ruleId),i={};await this.api.delete(a,i,{headers:c(this,h)[h]({path:a,body:i,method:"DELETE"})})}async getRuleInPolicy(e){let a=t.getPolicyRulePath(e.policyId),{data:i}=await this.api.get(a);return i}async getTransaction({id:e}){let{data:a}=await this.api.get(t.getTransactionGetPath(e));return{id:a.id,walletId:a.wallet_id,caip2:a.caip2,transactionHash:a.transaction_hash,status:a.status}}async create(e){return await this.createWallet(e)}async createWallet(e){let{chainType:a,policyIds:i}=e,r={chain_type:a,policy_ids:i,...s.translateOwnerInput({input:e}),...s.translateSignersInput({input:e})},n=s.extractIdempotencyKeyHeader(e),{data:o}=await this.api.post(t.getWalletApiCreatePath(),r,{headers:{...n}});return d.WalletView(o)}async updateWallet(e){let{id:a,policyIds:i}=e,r={policy_ids:i,...s.translateOwnerInput({input:e}),...s.translateSignersInput({input:e})},n=s.createAuthorizationSignatureHeader({method:"PATCH",url:`${this.api.baseURL}${t.getWalletApiUpdatePath(a)}`,body:r,appId:this.appId,authorizationPrivateKey:this.authorizationPrivateKey}),{data:o}=await this.api.patch(t.getWalletApiUpdatePath(a),r,{headers:{...n}});return d.WalletView(o)}async importWallet(e){return d.WalletView(await i.handleWalletImport(this.api,e))}async rpc(a){let i;if("walletId"in a)i=t.getWalletApiRpcPath(a.walletId);else{if(!("address"in a))throw new e.PrivyClientError("Invalid RPC payload. Must include `walletId`.");{console.warn("Warning: using deprecated input 'address' this will be removed in a a future version. Use 'walletId' instead.");let r=await s.getWalletIdFromAddress(this.api,a.address);if(!r)throw new e.PrivyClientError(`No wallet account found for address ${a.address}`);i=t.getWalletApiRpcPath(r)}}let r=function(e){let{method:t,params:a}=e,i="address"in e?{address:e.address,chain_type:e.chainType}:{wallet_id:e.walletId};switch(t){case"signTransaction":return{...i,method:t,params:{transaction:Buffer.from(a.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"signMessage":{let e=Buffer.from(a.message).toString("base64");return{...i,method:t,params:{message:e,encoding:"base64"}}}case"signAndSendTransaction":return{...i,method:t,caip2:e.caip2,params:{transaction:Buffer.from(a.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"eth_signTransaction":return{...i,method:t,params:{transaction:{from:a.transaction.from,to:a.transaction.to,nonce:a.transaction.nonce,chain_id:a.transaction.chainId,data:a.transaction.data,value:a.transaction.value,type:a.transaction.type,gas_limit:a.transaction.gasLimit,gas_price:a.transaction.gasPrice,max_fee_per_gas:a.transaction.maxFeePerGas,max_priority_fee_per_gas:a.transaction.maxPriorityFeePerGas}}};case"personal_sign":let r;return r=a.message instanceof Uint8Array?{message:Buffer.from(a.message).toString("hex"),encoding:"hex"}:a.message.startsWith("0x")?{message:a.message,encoding:"hex"}:{message:a.message,encoding:"utf-8"},{...i,method:t,params:r};case"eth_signTypedData_v4":return{...i,method:t,params:{typed_data:{domain:a.typedData.domain,types:a.typedData.types,message:a.typedData.message,primary_type:a.typedData.primaryType}}};case"eth_sendTransaction":return{...i,method:t,caip2:e.caip2,params:{transaction:{from:a.transaction.from,to:a.transaction.to,nonce:a.transaction.nonce,chain_id:a.transaction.chainId,data:a.transaction.data,value:a.transaction.value,type:a.transaction.type,gas_limit:a.transaction.gasLimit,gas_price:a.transaction.gasPrice,max_fee_per_gas:a.transaction.maxFeePerGas,max_priority_fee_per_gas:a.transaction.maxPriorityFeePerGas}}};default:throw Error(`Unsupported method: ${t}`)}}(a),n=s.extractIdempotencyKeyHeader(a),o=s.createAuthorizationSignatureHeader({method:"POST",url:`${this.api.baseURL}${i}`,body:r,appId:this.appId,idempotencyKeyHeader:n,authorizationPrivateKey:this.authorizationPrivateKey}),{data:d}=await this.api.post(i,r,{headers:{...o,...n}});return await async function(e,t){switch(t.method){case"signMessage":return{method:t.method,data:{signature:Buffer.from(t.data.signature,"base64")}};case"signTransaction":let a,i=e.params.transaction,r=Buffer.from(t.data.signed_transaction,"base64"),{Transaction:n,VersionedTransaction:o}=await import("@solana/web3.js");return a="version"in i?o.deserialize(r):n.from(r),{method:t.method,data:{signedTransaction:a}};case"signAndSendTransaction":if(t.data)return{method:t.method,data:{transactionId:t.data.transaction_id,hash:t.data.hash,caip2:t.data.caip2}};if(t.error)return{method:t.method,error:{code:t.error.code,message:t.error.message}};throw Error("Unexpected API response to signAndSendTransaction");case"eth_signTransaction":return{method:t.method,data:{signedTransaction:t.data.signed_transaction,encoding:t.data.encoding}};case"eth_sendTransaction":if(t.data)return{method:t.method,data:{transactionId:t.data.transaction_id,hash:t.data.hash,caip2:t.data.caip2}};if(t.error)return{method:t.method,error:{code:t.error.code,message:t.error.message}};throw Error("Unexpected API response to eth_sendTransaction");case"personal_sign":case"eth_signTypedData_v4":return{method:t.method,data:{signature:t.data.signature,encoding:t.data.encoding}};default:throw Error("Unsupported method")}}(a,d)}constructor({appId:e,api:t,authorizationPrivateKey:a}){Object.defineProperty(this,h,{value:l}),this.authorizationPrivateKey=null,this.api=t,a&&(this.authorizationPrivateKey=s.normalizeP256PrivateKeyToScalar(a)),this.appId=e,this.ethereum=new n.EthereumRpcApi({appId:e,api:t,authorizationPrivateKey:this.authorizationPrivateKey}),this.solana=new o.SolanaRpcApi({appId:e,api:t,authorizationPrivateKey:this.authorizationPrivateKey})}},exports.formatRequestForAuthorizationSignature=function({input:e}){return s.formatAuthorizationSignatureRequest({method:e.method,body:e.body,url:e.url,appId:e.headers["privy-app-id"],idempotencyKeyHeader:e.headers["privy-idempotency-key"]?{"privy-idempotency-key":e.headers["privy-idempotency-key"]}:void 0})},exports.generateAuthorizationSignature=function({input:e,authorizationPrivateKey:t}){let a;try{a=s.normalizeP256PrivateKeyToScalar(t)}catch(e){throw Error("Invalid authorization key format. Expected Privy-specific Authorization private key (wallet-auth:...)")}return s.signAuthorizationSignatureRequest({method:e.method,url:e.url,body:e.body,appId:e.headers["privy-app-id"],idempotencyKeyHeader:e.headers["privy-idempotency-key"]?{"privy-idempotency-key":e.headers["privy-idempotency-key"]}:void 0,authorizationPrivateKey:a})};
