import{PrivyClientError as a}from"../errors.mjs";import{getWalletApiSearchPath as t,getWalletApiGetPath as e,getPolicyPath as i,updatePolicyPath as r,deletePolicyPath as n,createPolicyRulePath as s,updatePolicyRulePath as o,deletePolicyRulePath as d,getPolicyRulePath as p,getTransactionGetPath as c,getWalletApiCreatePath as h,getWalletApiUpdatePath as m,getWalletApiRpcPath as y,createPolicyPath as u}from"../paths.mjs";import{g as l}from"../utils-DDjlFg8J.mjs";import{handleWalletImport as g}from"./import.mjs";import{convertPolicyResponseToPolicy as f,convertPolicyCreateRequestToPolicy as _,convertPolicyCreateRuleToPolicyRule as v}from"./mappers.mjs";import{EthereumRpcApi as w}from"./rpc/ethereum.mjs";import{SolanaRpcApi as P}from"./rpc/solana.mjs";import{normalizeP256PrivateKeyToScalar as I,createP256KeyPair as b,decryptHPKEMessage as z,translateOwnerInput as K,translateSignersInput as T,extractIdempotencyKeyHeader as x,createAuthorizationSignatureHeader as S,getWalletIdFromAddress as j,signAuthorizationSignatureRequest as k,formatAuthorizationSignatureRequest as E}from"./utils.mjs";import{WalletView as A}from"./views.mjs";import"node-fetch-native";import"ts-case-convert";import"@scure/base";import"viem";import"@hpke/chacha20poly1305";import"@hpke/core";import"@noble/curves/p256";import"@noble/hashes/sha256";import"canonicalize";import"../constants.mjs";function H(a,t){if(!Object.prototype.hasOwnProperty.call(a,t))throw TypeError("attempted to use private field on non-instance");return a}var U=0,D="__private_"+U+++"__getRequestHeaders";class R{async getWallets(a={}){let{cursor:e,limit:i,chainType:r}=a,{data:n}=await this.api.get(t()+l({cursor:e,limit:i,chain_type:r}));return{nextCursor:n.next_cursor??void 0,data:n.data.map((a=>A(a)))}}async getWallet({id:a}){let{data:t}=await this.api.get(e(a));return A(t)}updateAuthorizationKey(a){this.authorizationPrivateKey=I(a),this.ethereum=new w({appId:this.appId,api:this.api,authorizationPrivateKey:this.authorizationPrivateKey}),this.solana=new P({appId:this.appId,api:this.api,authorizationPrivateKey:this.authorizationPrivateKey})}async generateUserSigner({userJwt:a}){let{publicKey:t,privateKey:e}=await b(),{data:i}=await this.api.post("/api/v1/user_signers/authenticate",{encryption_type:"HPKE",recipient_public_key:t.toString("base64"),user_jwt:a});return{authorizationKey:await z(e.toString("base64"),i.encrypted_authorization_key.encapsulated_key,i.encrypted_authorization_key.ciphertext),expiresAt:new Date(i.expires_at),wallets:i.wallets.map((a=>A(a)))}}async getPolicy({id:a}){let{data:t}=await this.api.get(i(a));return f(t)}async createPolicy(a){let t=u(),e=_(a),{data:i}=await this.api.post(t,e,{headers:H(this,D)[D]({path:t,body:e,method:"POST"})});return f(i)}async updatePolicy(a){let t=r(a.id),e={name:a.name,rules:a.rules?v(a.rules):void 0},{data:i}=await this.api.patch(t,e,{headers:H(this,D)[D]({path:t,body:e,method:"PATCH"})});return f(i)}async deletePolicy(a){let t=n(a.id),e={};await this.api.delete(t,e,{headers:H(this,D)[D]({path:t,body:e,method:"DELETE"})})}async addRuleToPolicy(a){let t=s(a.policyId),e={name:a.name,action:a.action,method:a.method,conditions:a.conditions},{data:i}=await this.api.post(t,e,{headers:H(this,D)[D]({path:t,body:e,method:"POST"})});return i}async updateRuleInPolicy(a){let t=o(a.policyId,a.ruleId),e={name:a.name,action:a.action,method:a.method,conditions:a.conditions},{data:i}=await this.api.patch(t,e,{headers:H(this,D)[D]({path:t,body:e,method:"PATCH"})});return i}async deleteRuleFromPolicy(a){let t=d(a.policyId,a.ruleId),e={};await this.api.delete(t,e,{headers:H(this,D)[D]({path:t,body:e,method:"DELETE"})})}async getRuleInPolicy(a){let t=p(a.policyId),{data:e}=await this.api.get(t);return e}async getTransaction({id:a}){let{data:t}=await this.api.get(c(a));return{id:t.id,walletId:t.wallet_id,caip2:t.caip2,transactionHash:t.transaction_hash,status:t.status}}async create(a){return await this.createWallet(a)}async createWallet(a){let{chainType:t,policyIds:e}=a,i={chain_type:t,policy_ids:e,...K({input:a}),...T({input:a})},r=x(a),{data:n}=await this.api.post(h(),i,{headers:{...r}});return A(n)}async updateWallet(a){let{id:t,policyIds:e}=a,i={policy_ids:e,...K({input:a}),...T({input:a})},r=S({method:"PATCH",url:`${this.api.baseURL}${m(t)}`,body:i,appId:this.appId,authorizationPrivateKey:this.authorizationPrivateKey}),{data:n}=await this.api.patch(m(t),i,{headers:{...r}});return A(n)}async importWallet(a){return A(await g(this.api,a))}async rpc(t){let e;if("walletId"in t)e=y(t.walletId);else{if(!("address"in t))throw new a("Invalid RPC payload. Must include `walletId`.");{console.warn("Warning: using deprecated input 'address' this will be removed in a a future version. Use 'walletId' instead.");let i=await j(this.api,t.address);if(!i)throw new a(`No wallet account found for address ${t.address}`);e=y(i)}}let i=function(a){let{method:t,params:e}=a,i="address"in a?{address:a.address,chain_type:a.chainType}:{wallet_id:a.walletId};switch(t){case"signTransaction":return{...i,method:t,params:{transaction:Buffer.from(e.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"signMessage":{let a=Buffer.from(e.message).toString("base64");return{...i,method:t,params:{message:a,encoding:"base64"}}}case"signAndSendTransaction":return{...i,method:t,caip2:a.caip2,params:{transaction:Buffer.from(e.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"eth_signTransaction":return{...i,method:t,params:{transaction:{from:e.transaction.from,to:e.transaction.to,nonce:e.transaction.nonce,chain_id:e.transaction.chainId,data:e.transaction.data,value:e.transaction.value,type:e.transaction.type,gas_limit:e.transaction.gasLimit,gas_price:e.transaction.gasPrice,max_fee_per_gas:e.transaction.maxFeePerGas,max_priority_fee_per_gas:e.transaction.maxPriorityFeePerGas}}};case"personal_sign":let r;return r=e.message instanceof Uint8Array?{message:Buffer.from(e.message).toString("hex"),encoding:"hex"}:e.message.startsWith("0x")?{message:e.message,encoding:"hex"}:{message:e.message,encoding:"utf-8"},{...i,method:t,params:r};case"eth_signTypedData_v4":return{...i,method:t,params:{typed_data:{domain:e.typedData.domain,types:e.typedData.types,message:e.typedData.message,primary_type:e.typedData.primaryType}}};case"eth_sendTransaction":return{...i,method:t,caip2:a.caip2,params:{transaction:{from:e.transaction.from,to:e.transaction.to,nonce:e.transaction.nonce,chain_id:e.transaction.chainId,data:e.transaction.data,value:e.transaction.value,type:e.transaction.type,gas_limit:e.transaction.gasLimit,gas_price:e.transaction.gasPrice,max_fee_per_gas:e.transaction.maxFeePerGas,max_priority_fee_per_gas:e.transaction.maxPriorityFeePerGas}}};default:throw Error(`Unsupported method: ${t}`)}}(t),r=x(t),n=S({method:"POST",url:`${this.api.baseURL}${e}`,body:i,appId:this.appId,idempotencyKeyHeader:r,authorizationPrivateKey:this.authorizationPrivateKey}),{data:s}=await this.api.post(e,i,{headers:{...n,...r}});return await async function(a,t){switch(t.method){case"signMessage":return{method:t.method,data:{signature:Buffer.from(t.data.signature,"base64")}};case"signTransaction":let e,i=a.params.transaction,r=Buffer.from(t.data.signed_transaction,"base64"),{Transaction:n,VersionedTransaction:s}=await import("@solana/web3.js");return e="version"in i?s.deserialize(r):n.from(r),{method:t.method,data:{signedTransaction:e}};case"signAndSendTransaction":if(t.data)return{method:t.method,data:{transactionId:t.data.transaction_id,hash:t.data.hash,caip2:t.data.caip2}};if(t.error)return{method:t.method,error:{code:t.error.code,message:t.error.message}};throw Error("Unexpected API response to signAndSendTransaction");case"eth_signTransaction":return{method:t.method,data:{signedTransaction:t.data.signed_transaction,encoding:t.data.encoding}};case"eth_sendTransaction":if(t.data)return{method:t.method,data:{transactionId:t.data.transaction_id,hash:t.data.hash,caip2:t.data.caip2}};if(t.error)return{method:t.method,error:{code:t.error.code,message:t.error.message}};throw Error("Unexpected API response to eth_sendTransaction");case"personal_sign":case"eth_signTypedData_v4":return{method:t.method,data:{signature:t.data.signature,encoding:t.data.encoding}};default:throw Error("Unsupported method")}}(t,s)}constructor({appId:a,api:t,authorizationPrivateKey:e}){Object.defineProperty(this,D,{value:W}),this.authorizationPrivateKey=null,this.api=t,e&&(this.authorizationPrivateKey=I(e)),this.appId=a,this.ethereum=new w({appId:a,api:t,authorizationPrivateKey:this.authorizationPrivateKey}),this.solana=new P({appId:a,api:t,authorizationPrivateKey:this.authorizationPrivateKey})}}function W({path:a,body:t,idempotencyKey:e,method:i}){let r=x({idempotencyKey:e}),n={...r};if(this.authorizationPrivateKey){let e=k({method:i,url:`${this.api.baseURL}${a}`,body:t,appId:this.appId,idempotencyKeyHeader:r,authorizationPrivateKey:this.authorizationPrivateKey});void 0!==e&&(n["privy-authorization-signature"]=e)}return n}function $({input:a,authorizationPrivateKey:t}){let e;try{e=I(t)}catch(a){throw Error("Invalid authorization key format. Expected Privy-specific Authorization private key (wallet-auth:...)")}return k({method:a.method,url:a.url,body:a.body,appId:a.headers["privy-app-id"],idempotencyKeyHeader:a.headers["privy-idempotency-key"]?{"privy-idempotency-key":a.headers["privy-idempotency-key"]}:void 0,authorizationPrivateKey:e})}function L({input:a}){return E({method:a.method,body:a.body,url:a.url,appId:a.headers["privy-app-id"],idempotencyKeyHeader:a.headers["privy-idempotency-key"]?{"privy-idempotency-key":a.headers["privy-idempotency-key"]}:void 0})}export{R as WalletApi,L as formatRequestForAuthorizationSignature,$ as generateAuthorizationSignature};
