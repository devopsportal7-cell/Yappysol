"use strict";var e=require("@scure/base"),t=require("viem"),r=require("../paths.js"),n=require("./utils.js");require("@hpke/chacha20poly1305"),require("@hpke/core"),require("@noble/curves/p256"),require("@noble/hashes/sha256"),require("canonicalize"),require("../constants.js"),require("../errors.js");let p=({entropy:r,entropyType:n,chainType:p})=>{switch(n){case"private-key":return(({entropy:r,chainType:n})=>{switch(n){case"ethereum":let n=r.startsWith("0x")?r:`0x${r}`;if(!t.isHex(n))throw Error("Invalid entropy: Ethereum entropy must be hex encoded");return new Uint8Array(Buffer.from(n.replace(/^0x/,""),"hex"));case"solana":let p;try{p=e.base58.decode(r)}catch(e){throw Error("Invalid entropy: Solana entropy must be base58 encoded")}return p}})({entropy:r,chainType:p});case"hd":return(({entropy:e})=>Buffer.from(e,"utf-8"))({entropy:r})}};exports.handleWalletImport=async(e,t)=>{let a=p({entropy:t.entropy,entropyType:t.entropyType,chainType:t.chainType}),{encryption_public_key:i}=await(async({apiClient:e,input:t})=>{let n;n="hd"===t.entropyType?{chain_type:t.chainType,address:t.address,entropy_type:t.entropyType,index:t.index,encryption_type:"HPKE"}:{chain_type:t.chainType,address:t.address,entropy_type:t.entropyType,encryption_type:"HPKE"};let{data:p}=await e.post(r.getWalletApiImportInitPath(),n);return p})({apiClient:e,input:t}),{encapsulatedKey:y,ciphertext:s}=await n.encryptHPKEMessage({encryptionPublicKey:new Uint8Array(Buffer.from(i,"base64")),plaintext:a});return await(async({apiClient:e,input:t,encapsulatedKey:p,ciphertext:a})=>{let i={wallet:"hd"===t.entropyType?{chain_type:t.chainType,address:t.address,encryption_type:"HPKE",ciphertext:a,encapsulated_key:p,entropy_type:t.entropyType,index:t.index}:{chain_type:t.chainType,address:t.address,encryption_type:"HPKE",ciphertext:a,encapsulated_key:p,entropy_type:t.entropyType},...n.translateOwnerInput({input:t}),...n.translateSignersInput({input:t})},{data:y}=await e.post(r.getWalletApiImportSubmitPath(),i);return y})({apiClient:e,input:t,encapsulatedKey:Buffer.from(y).toString("base64"),ciphertext:Buffer.from(s).toString("base64")})};
